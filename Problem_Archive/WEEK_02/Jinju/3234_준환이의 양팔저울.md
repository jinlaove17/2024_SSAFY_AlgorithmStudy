## C++과 Java의 재귀 최적화 차이 발견
### C++ 과 Java가 각각 같은 로직으로 재귀가 구현되었음에도 불구하고 시간 제한 차이로 인해 AC/WA가 달라진다.


1. Java 백트래킹 (수현 오빠 코드)

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

//백트래킹을 구현할 때 배열에 대해 전역변수를 사용하게 될 시에 테스트 케이스가 많아질 수록 재사용량 또한 증가하는 경향이 존재한다.
//그에 따라 백트래킹 시 전역 변수의 상태 관리가 복잡해지고 오류 발생 가능성이 높아진다 -> 시간 초과, 메모리 사용량 초과의 주요 원인
// 백트래킹 시 전역 변수 사용을 주의하고 가능한 로컬 변수를 사용하자
// 실제로 weights, visit를 전역으로 사용할 때는 시간 초과로 문제를 통과하지 못했으나 지역변수로 전환 시 통과하였다.
class Solution
{
    static int result;
    //static int[] weights;
    //static boolean[] visit;

    public static void main(String args[]) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        StringBuilder sb = new StringBuilder();
        int T = Integer.parseInt(br.readLine().trim());
        for(int t=1; t<=T; t++) {
            int N = Integer.parseInt(br.readLine().trim());
            int[] weights= new int[N];
            boolean[] visit = new boolean[N];
            st=new StringTokenizer(br.readLine().trim());
            for(int i=0; i<N; i++) {
                weights[i] = Integer.parseInt(st.nextToken());
            }
            result=0;
            backTrack(0,0,0,N, weights, visit);
            sb.append("#"+t+" "+result+"\n");
        }
        System.out.println(sb.toString());
    }

    public static void backTrack(int left, int right, int count, int N, int[] weights, boolean[] visit) {
        if(count == N) {
            result++;
            return;
        }
        for(int i=0; i<N; i++) {
            if(visit[i])
                continue;
            visit[i]=true;
            backTrack(left+weights[i], right, count+1, N, weights, visit);
            if(left >= right+weights[i])
                backTrack(left,right+weights[i], count+1, N, weights, visit);
            visit[i]=false;
        }
    }
}
```


2. C++ 백트래킹 (TLE)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
using namespace std;

int T, maxW;
int ret = 0;

void dfs(bool vst[], int weight[], int leftW, int rightW, int N, int depth) {

	if (leftW < rightW) {
		//가지치기: 오른쪽 저울 무게가 더 큰 경우
		return;
	}

	if (leftW + rightW == maxW) {
		//경우의 수 result+1 : 모든 추가 저울에 올라갔을 때
		ret++;
		return;
	}

	if (depth >= N) return; //가지치기: depth를 이용

	//방문하지 않은 곳일 때 백트래킹
	for (int i = 0; i < N; i++) {
		if (vst[i]) continue;
		else {
			vst[i] = true;

			//1. 왼쪽 저울에 추가
			dfs(vst, weight, leftW + weight[i], rightW, N, depth + 1);

			//2. 오른쪽 저울에 추가
			if (leftW >= rightW + weight[i]) {
				dfs(vst, weight, leftW, rightW + weight[i], N, depth + 1);
			}
			vst[i] = false;
		}
	}
}

int main(void) {
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(0);
	cin >> T;

	for (int t = 1; t <= T; t++) {
		int N;
		int weight[10] = { 0, };
		bool used[10] = { false, };

		maxW = 0;
		ret = 0;
		cin >> N;
		for (int w = 0; w < N; w++) {
			cin >> weight[w];
			maxW += weight[w];
		}

		memset(weight, 0, sizeof(weight));
		memset(used, 0, sizeof(used));

		for (int i = 0; i < N; i++) {
			used[i] = true;
			dfs(used, weight, weight[i], 0, N, 1);
			used[i] = false;
		}

		cout << "#" << t << " " << ret << "\n";
	}
	return 0;
}
```


3. C++ (팩토리얼을 이용한 가지치기 추가)
```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int MAX = 10;
 
int N, ret, maxW;
int weight[MAX];
bool used[MAX];
int expo[MAX] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };
int fact[MAX] = { 0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };
 
void dfs(int cnt, int left, int right) {
 
    if (cnt == N) { // 모든 무게추를 올린 경우
        ret++;
        return;
    }
 
    if (maxW - left <= left) {
        // 남은 추를 어떻게 올려도 상관 없는 경우 
        ret += expo[N - cnt] * fact[N - cnt];
        return;
    }
 
    for (int i = 0; i < N; i++) {
 
        if (used[i]) continue;
 
        used[i] = true;
        dfs(cnt + 1, left + weight[i], right);
 
        if (right + weight[i] <= left) {
            dfs(cnt + 1, left, right + weight[i]);
        }
             
        used[i] = false;
    }
}
 
int main() {
    cin.tie(0);
    cout.tie(0);
    ios_base::sync_with_stdio(0);
 
    int T; 
    cin >> T;
 
    for (int t = 1; t <= T; t++) {
 
        ret = 0;
        maxW = 0;
        memset(used, false, sizeof(used));
 
        cin >> N;
        for (int i = 0; i < N; i++) {
            cin >> weight[i];
            maxW += weight[i];
        }
         
        dfs(0, 0, 0);
        cout << "#" << t << " " << ret << "\n";
    }
    return 0;
}
```


### Java의 메모리 구조
- JVM이 관리
- MetaData 영역 / Stack 영역 / Heap 영역
- 재귀, 백트래킹 함수 호출하는 과정 살펴보기
  - 전역 변수는 MetaData 영역에 올라간다.
  - 지역 변수는 실행 중인 함수와 함께 stack에 할당된다.
  - 재귀로 실행하는 함수들은 stack 영역에 쌓인다. (전달하는 파라미터와 함께 호출 끝나고 되돌아 갈 주소가 맨 위에 쌓임)
  - 매개 변수를 주고 받을 때도 stack에 계속 쌓이면서 주고 받는다. (여기서 메모리 접근 차이 추측)
- [참고자료](https://yaboong.github.io/java/2018/05/26/java-memory-management/)


### 결론
- 단순 비교로 메모리와 실행 시간을 비교하면 C++이 당연히 우위에 있음
- Java의 다양한 상황을 고려하여 제한시간이 1초 추가 되었는데, 지역 변수를 활용하여 최적화하면 2초 내에 전체 탐색이 다 돌아간다.
  (C++에서 가지치기를 추가한 버전으로 돌리면 Java로는 1초 내외로 결과 나옴)
- 이 외에도 Java는 JVM의 메모리 자동관리, 함수 최적화 등의 요소로 인해 차이가 있으나 미미한 차이이며 유의미한 차이는 아닐듯?


