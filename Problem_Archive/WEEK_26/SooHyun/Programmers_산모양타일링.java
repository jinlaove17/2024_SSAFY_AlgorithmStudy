/*
문제 접근 아이디어 및 알고리즘 판단 사유
	- 해당 문제는 2023년 당시 카카오 인턴쉽 코딩테스트 문제로 처음 접했고 그 당시에 건들지 못했던 문제입니다. 그로 인해 이번 스터디 문제로 가져왔습니다.
	- 문제를 읽어보면 10007로 나눈 나머지를 구하는 조건을 보고 DP 냄새가 많이 났습니다. 그에 따라 어떠한 조건으로 dp를 구성해야하는지가 관건이였습니다.
	- 문제 풀이의 핵심은 뒤집어진 삼각형이 어떠한 것으로 채워지냐였습니다.
	- tops의 값에 상관없이 모두 단일 삼각형으로 채워지는 경우는 반드시 존재했습니다. 그리고 그 경우의 수는 1가지입니다. 그것 이외에 tops의 값에 의해 만들어질 수 있는 경우의 수가 달라지는 것을 확인했습니다.
	- 이번 문제는 다른 dp문제와 달리 dp 배열을 2가지 선언해야했습니다. dp1은 i번째 tops 이전에 모두 작은 삼각형으로 채워져있고 나머지를 어떻게 채우는 경우의 수를 저장합니다.
	- dp2는 i번째 tops 전에 단일 삼각형으로 전부 채워지지 않은 상태에서 채워지는 경우의 수를 저장합니다.
	- dp1[0]은 따라서 1로 초기화하고 dp2[0]는 tops[0]가 1인 경우에 3개의 경우의 수가 나오고 0인 경우에는 2가지의 경우의 수가 나옵니다.
	- 이후 i=1부터 n-1까지의 반복문을 순회하면서 tops[i]에 따라서 dp2[i]의 값이 결정됩니다.
	- dp1[i]은 dp1[i-1]과 dp2[i-1]의 합으로 결정됩니다.
	- dp2[i]는 tops[i]가 0인 경우 dp1[i-1]를 그대로 가져오고 dp2[i-1]의 경우 2를 곱한 값을 가져옵니다. 이에 반해 tops[i]가 1인 경우 기존 dp1[i-1] 가짓수에 2를 곱한 값을 가져오고 dp2[i-1]의 값에 3을 곱한 값을 더한 값입니다.
	- 최종적으로 dp1[n-1]과 dp2[n-1]의 합을 10007로 나눈 나머지를 구하면 답이 됩니다.
	- 이렇게 말로 적게되면 이해가 잘되지 않는 부분이 존재해 스터디 시간에 직접 그림으로 설명해드리겠습니다.

시간 복잡도
	- 초기화 : O(1)
    - DP : O(N)
    - 전체 시간복잡도: O(N)

실행 시간
	- 7.14ms(java)

*/
import java.util.*;
class Solution {
    int MOD = 10007;
    public int solution(int n, int[] tops) {
        int answer = 0;
        int[] dp1 = new int[n];
        int[] dp2 = new int[n];
        dp1[0]=1;
        if(tops[0]==1){
            dp2[0]=3;
        }else{
            dp2[0]=2;
        }
        for(int i=1; i<n; i++){
            dp1[i] = (dp1[i-1]+dp2[i-1])%MOD;
            if(tops[i]==1){
                dp2[i] = (dp1[i-1]*2 + dp2[i-1]*3) % MOD;
            }else{
                dp2[i] = (dp1[i-1] + dp2[i-1]*2) % MOD;
            }
        }
        answer = (dp1[n-1] + dp2[n-1]) %MOD;
        return answer;
    }
}