/*
문제 접근 아이디어 및 알고리즘 판단 사유
	- 문제를 읽어보면 어떤 규칙성이 있을 것만 같고, 10억3으로 나눈 나머지를 구해야 한다는 점에서 다이나믹 프로그래밍(DP)으로 접근을 시작했다.
	  우선, k가 1인 경우에는 n개의 색상 중 1개만 고르는 것이기 때문에 인접한 색상을 고려하지 않으므로 n개의 경우의 수가 존재하여 별도로 처리하였다.
	  k가 1이 아닐때는 dp 테이블을 사용해야 하는데, dp[i][j]는 i개의 색상 중, 인접하지 않도록 j개를 선택하는 경우의 수로 정의하였다.
	  i개의 색상 중 1개를 고르는 것은, i가지의 경우가 존재하므로 초기화 단계에서 dp[i][1]을 모두 i로 초기화한다.
	  이제 n x k번 반복문을 수행하면서, i번째 색을 선택하지 않고 i - 1번째 색 중 k개를 선택했을 때와 i번째 색을 선택하고, i - 2번째 색 중 k - 1개를 선택했을 때의 합이
	  i개의 색상으로 인접하지 않고 j개를 선택하는 경우의 수가 된다.
	  최종적으로 첫 번째 색을 선택했을 때와, 선택하지 않았을 때로 나누는데, 첫 번째 색을 선택했다면 인접 2칸은 색을 선택할 수 없기 때문에 n - 3개 중에 k - 1개를 선택하면 되고,
	  선택하지 않았을 때는 첫 번째 칸을 제외한 n - 1개 중에 k개를 선택하면 된다.
	  위 두 경우를 더하고 MOD로 나눈 나머지를 구하면 문제에서 원하는 답을 도출할 수 있다.

시간 복잡도
	- n개의 색상에 대해, k개를 택하는 경우의 수를 따져보기 때문에 n * k의 연산이 수행된다.
	  따라서 O(n * k)의 시간 복잡도를 갖는다.

실행 시간
	- 4ms
*/

#include <iostream>

using namespace std;

const int MOD = 1e9 + 3;
const int MAX_COLOR_COUNT = 1'000;

int n, k;
int dp[MAX_COLOR_COUNT + 1][MAX_COLOR_COUNT + 1]; // dp[i][j]: i개의 색상 중 인접하지 않도록 j개를 선택하는 경우의 수

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> k;

	if (k == 1)
	{
		cout << n << '\n';
	}
	else
	{
		for (int i = 1; i <= n; ++i)
		{
			dp[i][1] = i;
		}

		for (int i = 2; i <= n; ++i)
		{
			for (int j = 2; j <= min(i, k); ++j)
			{
				dp[i][j] = (dp[i - 1][j] + dp[i - 2][j - 1]) % MOD;
			}
		}

		cout << (dp[n - 3][k - 1] + dp[n - 1][k]) % MOD << '\n';
	}
}
