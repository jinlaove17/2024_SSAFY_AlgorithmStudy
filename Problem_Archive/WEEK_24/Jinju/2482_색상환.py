import sys
input = sys.stdin.readline
MOD = 1_000_000_003
N = int(input())
K = int(input())
dp = [[0]*1001 for _ in range(1001)]

# 문제 접근
# 원 형태에서 뭔가를 처리해주려면 일단 원 형태를 직선 배열로 펴야한다.
# 직선 배열로 폈을 때, 원 만나는 부분 (시작, 끝) 처리를 주의해야 한다.
# 주로 이를 다루는 트릭이 두 가지가 있는데,
#  1. 배열을 펼친 후에, 맨 끝(N)에서만 특별한 처리나 조건 봐주기
#  2. 배열을 약 2배 길이로 넉넉하게 펼쳐서 원 연결된 부분의 값을 copy해서 채워준다.

# 또한, 색상환을 잘 보면 특별한 경우가 생기는데, 첫 칸을 기준으로
# 본인 색을 선택하면, 옆 칸은 무조건 비워야 한다.
# -> 즉, 본인을 제외하고 최소 2칸을 소모한다는 소리이다.
# -> N/K 의 몫이 2보다 작은 경우에는 무조건 불가능하다는 의미이다. (Case 처리로 빼주기)
# 점화식은 본인을 선택하는 경우와 선택하지 않는 경우를 파악해줘야 한다.

# 마지막 N번째에서 원을 생각한 특수 처리 (첫 번째를 선택했을 때와 안 했을 때를 나눠서 더하기)
# -> 첫 번째 색상을 선택한 경우, 마지막 색상 역시 선택할 수 없으므로 이를 고려해야 한다.

if N//K < 2:
    print(0)
else:
    for i in range(N+1):
        dp[i][1] = i
        dp[i][0] = 1

    for i in range(2, N+1):
        for j in range(2, K+1):
            dp[i][j] = (dp[i-2][j-1] + dp[i-1][j])%MOD

    res = (dp[N-1][K] + dp[N-3][K-1])%MOD
    print(res)
